<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        user-select: none;
      }

      #reset-btn {
        position: absolute;
        top: 10px;
        left: 10px;
      }

      .label-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;

        .label {
          color: #ffffff;
          cursor: pointer;
        }
      }

      .popup {
        position: absolute;
        top: 0;
        left: 0;
        width: 100px;
        height: 100px;
        background-color: #000000;
        display: none;
      }
    </style>
  </head>
  <body>
    <button id="reset-btn">复位</button>
    <div class="popup"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "/node_modules/three/build/three.module.js",
          "three/addons/": "/node_modules/three/examples/jsm/"
        }
      }
    </script>
    <script src="/node_modules/d3/dist/d3.min.js">
      // d3不符合es module规范，所以直接请求
    </script>
    <script src="/node_modules/gsap/dist/gsap.js"></script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { CSS2DObject, CSS2DRenderer } from "three/addons/renderers/CSS2DRenderer.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      let geoJSON = null;

      await fetch("./geojson/china.json")
        .then((res) => {
          return res.json();
        })
        .then((data) => {
          geoJSON = data;
        });

      let camera, scene, renderer, controls;
      let labelRenderer;
      let raycaster, mouse;
      let popupPosition = null;
      let isDrag = false;
      const centerCoord = [108.9534688, 34.2704779];

      let helpers = [];

      const colorMap = {
        西北: "#C6E0FF",
        东北: "#506EA3",
        华北: "#91AEDC",
        华东: "#6D89C0",
        华中: "#8AA5DE",
        华南: "#BDD2EF",
        西南: "#4986D2",
        台湾: "#79a1dc",
        香港: "#d0dff4",
        澳门: "#d0dff4",
        JD: "#a0bfe4",
      };
      const lightProp = {
        intensity: 1,
        x: 0,
        y: 0,
        z: 0,
      };

      createWorld();
      createMap(geoJSON);
      createLight();
      createGUI();
      document.querySelector("#reset-btn").addEventListener("click", handleReset);

      function createWorld() {
        // 创建场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeaedf5);
        scene.fog = new THREE.Fog(0xeaedf5, 30, 600);

        // 创建相机
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 70;
        camera.up.set(0, 0, 1);
        camera.layers.enableAll();

        // 创建渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;

        // 创建控制器
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        // controls.enablePan = false;
        controls.maxPolarAngle = 1.5;
        controls.maxDistance = 90;
        controls.minDistance = 10;
        controls.addEventListener("change", () => {
          // 放大后 polarAngle 仍为1.5的话会穿透地图；所以限制 z 范围，避免放大后穿透地图
          const z = controls.object.position.z;
          controls.object.position.z = z < 10 ? 10 : z > 90 ? 90 : z;

          // scale 范围: [0.5, 5]
          updateSpriteScale((3 / 40) * controls.getDistance() - 0.25);
        });

        controls.addEventListener("end", () => {
          if (Math.abs(controls.target.x) > 100 || Math.abs(controls.target.y) > 80) {
            handleReset();
          }
        });

        // 添加光源
        const light = new THREE.AmbientLight(0xffffff, 2.4);
        scene.add(light);

        // 创建基础平面
        createBasicPlane();

        // 创建动效平面
        createTexturePlane();

        // 创建坐标轴
        const axesHelper = new THREE.AxesHelper(20);
        scene.add(axesHelper);

        // 创建射线
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // 创建网格
        // const gridHelper = new THREE.GridHelper(200, 20, "#cccccc", "#cccccc");
        // gridHelper.rotation.x = Math.PI / 2;
        // gridHelper.position.z = 0.01;
        // scene.add(gridHelper);

        // 渲染场景
        function render() {
          requestAnimationFrame(render);

          renderer.render(scene, camera);
          controls.update();

          if (labelRenderer) {
            labelRenderer.render(scene, camera);
          }

          if (helpers?.length) {
            helpers.forEach((h) => {
              h.update();
            });
          }
        }
        render();

        window.addEventListener("resize", handleResize);
        window.addEventListener("click", handleClick);
        window.addEventListener("mousedown", () => {
          isDrag = false;
        });
        window.addEventListener("mousemove", () => {
          if (!isDrag) isDrag = true;
        });
      }

      function createBasicPlane() {
        const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0xebeff8, // f5f8ff
          side: THREE.FrontSide,
          map: new THREE.TextureLoader().load("/texture/plane-bg.png"),
          depthWrite: false,
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;
        scene.add(plane);
      }

      function createRotatePlane() {
        ["clockwise-circle.png", "anti-clockwise-circle.png"].forEach((name) => {
          const planeGeometry = new THREE.PlaneGeometry(170, 170);
          const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x91aedc,
            side: THREE.FrontSide,
            map: new THREE.TextureLoader().load(`/texture/${name}`),
            transparent: true,
            depthWrite: false,
          });
          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(-2, -3, 0);
          scene.add(plane);

          gsap.to(plane.rotation, {
            z: (name.includes("anti") ? 1 : -1) * Math.PI * 2,
            duration: name.includes("anti") ? 6 : 10,
            repeat: -1,
            ease: "none",
          });
        });
      }

      function createMap(data) {
        const map = new THREE.Group();
        scene.add(map);

        createLand(map, data);
        createBoundary(map, data);
        createLabel(map, data);
        createSpritePoint(map);
      }

      function createLand(map, data) {
        data.features.forEach((feature) => {
          const group = new THREE.Group();

          if (feature.type === "Feature") {
            const { properties, geometry } = feature;
            const { region } = properties;
            const { type, coordinates } = geometry;

            if (type === "MultiPolygon") {
              coordinates.forEach((polygon) => {
                group.add(createPolygon(colorMap[region], polygon));
              });
            } else if (type === "Polygon") {
              group.add(createPolygon(colorMap[region], coordinates));
            }
          }
          group.position.z = 1;

          map.add(group);
        });
      }

      function createBoundary(map, data) {
        data.features.forEach((feature) => {
          const group = new THREE.Group();

          if (feature.type === "Feature") {
            const { properties, geometry } = feature;
            const { name } = properties;
            const { type, coordinates } = geometry;

            if (type === "MultiPolygon") {
              coordinates.forEach((polygon) => {
                group.add(createPolyline(polygon));
              });
            } else if (type === "Polygon") {
              group.add(createPolyline(coordinates));
            }
          }
          group.position.z = 3.1;

          map.add(group);
        });
      }

      function createLabel(map, data) {
        if (!labelRenderer) {
          labelRenderer = new CSS2DRenderer();
          labelRenderer.setSize(window.innerWidth, window.innerHeight);
          labelRenderer.domElement.className = "label-container";
          document.body.appendChild(labelRenderer.domElement);
        }
        const group = new THREE.Group();

        data.features.forEach((feature) => {
          if (feature.type === "Feature") {
            const { center, name } = feature.properties;
            if (name && center) {
              group.add(createText(name, center));
            }
          }
        });

        map.add(group);
      }

      function createPolygon(color, polygon) {
        const projection = d3.geoMercator().center(centerCoord).scale(100).translate([0, 0]);

        const shape = new THREE.Shape();

        polygon.forEach((ring) => {
          ring.forEach((point) => {
            const [x, y] = projection(point);
            shape.moveTo(x, -y);
            shape.lineTo(x, -y);
          });

          shape.closePath();
        });

        shape.closePath();

        const geometry = new THREE.ExtrudeGeometry(shape, { depth: 2, bevelEnabled: false });
        const surfaceMaterial = new THREE.MeshStandardMaterial({ color, side: THREE.FrontSide });
        const sideMaterial = new THREE.MeshLambertMaterial({ color: "#d0e1f5", side: THREE.FrontSide });
        const mesh = new THREE.Mesh(geometry, [surfaceMaterial, sideMaterial]);
        mesh.castShadow = true;

        return mesh;
      }

      function createPolyline(polyline) {
        const projection = d3.geoMercator().center(centerCoord).scale(100).translate([0, 0]);

        const vertices = [];

        polyline.forEach((ring) => {
          ring.forEach((point) => {
            const [x, y] = projection(point);
            vertices.push(new THREE.Vector3(x, -y, 0));
          });
        });

        const geometry = new THREE.BufferGeometry();
        geometry.setFromPoints(vertices);

        const material = new THREE.LineBasicMaterial({ color: 0xffffff });

        const line = new THREE.Line(geometry, material);

        return line;
      }

      function createText(textContent, point) {
        const projection = d3.geoMercator().center(centerCoord).scale(100).translate([0, 0]);
        const [x, y] = projection(point);

        const ele = document.createElement("div");
        ele.className = "label";
        ele.textContent = textContent;

        const text = new CSS2DObject(ele);
        text.position.set(x, -y, 3);
        text.layers.set(1);

        return text;
      }

      function createSpritePoint(map, data) {
        const projection = d3.geoMercator().center(centerCoord).scale(100).translate([0, 0]);
        data = [centerCoord, [117.9534688, 30.2704779], [119.9534688, 28.2704779]];

        const group = new THREE.Group();

        data.forEach((coord) => {
          const [x, y] = projection(coord);
          const map = new THREE.TextureLoader().load("/texture/01.png");
          const material = new THREE.SpriteMaterial({ map, depthTest: false });
          const sprite = new THREE.Sprite(material);
          sprite.center.set(0.5, 0);
          sprite.position.set(x, -y, 3.1);
          sprite.scale.set(5, 5, 1);
          sprite.name = "sprite";
          group.add(sprite);
        });

        map.add(group);
      }

      function createLight() {
        const light = new THREE.DirectionalLight("#ffffff", 1);
        light.position.set(-20, 20, 60);
        light.castShadow = true;
        light.name = "light";

        // // 设置阴影贴图模糊度
        light.shadow.radius = 10;
        // // 设置阴影贴图的分辨率
        light.shadow.mapSize.set(2 ** 12, 2 ** 12);
        // 设置平行光投射相机的属性
        light.shadow.camera.near = 10;
        light.shadow.camera.far = 100;
        light.shadow.camera.top = 100;
        light.shadow.camera.bottom = -100;
        light.shadow.camera.left = -100;
        light.shadow.camera.right = 100;
        // 添加灯光到场景中
        scene.add(light);

        // const helper1 = new THREE.DirectionalLightHelper(light);
        // const helper2 = new THREE.CameraHelper(light.shadow.camera);
        // helpers.push(helper1);
        // helpers.push(helper2);
        // scene.add(helper1);
        // scene.add(helper2);
      }

      function createTexturePlane() {
        const sources = ["/texture/clockwise-circle.png", "/texture/anti-clockwise-circle.png"];

        sources.forEach((url) => {
          const planeGeometry = new THREE.PlaneGeometry(170, 170);
          const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x91aedc,
            side: THREE.FrontSide,
            map: new THREE.TextureLoader().load(url),
            transparent: true,
            depthWrite: false,
            needsUpdate: true,
          });
          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          scene.add(plane);

          gsap.to(plane.rotation, {
            z: (url.includes("anti") ? 1 : -1) * Math.PI * 2,
            duration: 6,
            repeat: -1,
            ease: "none",
          });
        });
      }

      function handleClick(event) {
        if (!event.target.getAttribute("data-engine")) return void 0;

        // 归一化处理
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(scene.getObjectsByProperty("name", "sprite"), true);

        if (intersects.length && !popupPosition) {
          popupPosition = intersects[0].object.position.clone();
          handlePopupMove();
          controls.addEventListener("change", handlePopupMove);
        } else if (!isDrag) {
          handlePopupClose();
        }
      }

      function handlePopupMove() {
        popupPosition.project(camera);
        const x = (popupPosition.x * 0.5 + 0.5) * window.innerWidth;
        const y = (popupPosition.y * -0.5 + 0.5) * window.innerHeight;
        const text = document.querySelector(".popup");
        text.style.display = "block";
        text.style.left = `${x}px`;
        text.style.top = `${y}px`;
      }

      function handlePopupClose() {
        popupPosition = null;
        const popup = document.querySelector(".popup");
        if (popup) {
          popup.style.display = "none";
        }
        controls.removeEventListener("change", handlePopupMove);
      }

      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        if (labelRenderer) {
          labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      function handleReset() {
        const duration = 1;

        camera.layers.toggle(1);
        controls.enableDamping = false;

        gsap.to(controls.target, { x: 0, y: 0, z: 0, duration });
        gsap.to(camera.rotation, { x: 0, y: 0, z: 0, duration });
        gsap.to(camera.position, {
          x: 0,
          y: 0,
          z: 70,
          duration,
          onComplete() {
            camera.layers.toggle(1);
            controls.enableDamping = true;
          },
        });
      }

      function updateSpriteScale(scale) {
        scene.getObjectsByProperty("name", "sprite").forEach((sprite) => {
          sprite.scale.set(scale, scale, 1);
        });
      }

      function createGUI() {
        const gui = new GUI();

        // const textureObj = {
        //   size: 130,
        // };

        // gui.add(textureObj, "size", 130, 200).onChange((value) => {
        //   scene.getObjectsByProperty("name", "texture-plane").forEach((plane) => {
        //     plane.geometry = new THREE.PlaneGeometry(value, value);
        //   });
        // });
      }
    </script>
  </body>
</html>
